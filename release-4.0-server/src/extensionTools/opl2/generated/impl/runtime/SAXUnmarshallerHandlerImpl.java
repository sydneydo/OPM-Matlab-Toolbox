//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v1.0.5-b16-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2006.05.23 at 12:36:13 PM IDT 
//

package extensionTools.opl2.generated.impl.runtime;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBException;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.ValidationEvent;
import javax.xml.bind.ValidationEventHandler;

import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.LocatorImpl;

import com.sun.xml.bind.JAXBAssertionError;
import com.sun.xml.bind.unmarshaller.Messages;
import com.sun.xml.bind.unmarshaller.Tracer;
import com.sun.xml.bind.util.AttributesImpl;

/**
 * Implementation of {@link UnmarshallerHandler}.
 * 
 * This object converts SAX events into unmarshaller events and
 * cooridnates the entire unmarshalling process.
 *
 * @author
 *  <a href="mailto:kohsuke.kawaguchi@sun.com">Kohsuke KAWAGUCHI</a>
 */
public class SAXUnmarshallerHandlerImpl
    implements SAXUnmarshallerHandler, UnmarshallingContext
{
    /**
     * This flag is set to true at the startDocument event
     * and false at the endDocument event.
     * 
     * Until the first document is unmarshalled, we don't
     * want to return an object. So this variable is initialized
     * to true.
     */
    private boolean isUnmarshalInProgress = true;
    
    
    
    public SAXUnmarshallerHandlerImpl( UnmarshallerImpl _parent, GrammarInfo _gi ) {
        this.parent = _parent;
        this.grammarInfo = _gi;
        this.startPrefixMapping("",""); // by default, the default ns is bound to "".
     }
    
    private final GrammarInfo grammarInfo;
    public GrammarInfo getGrammarInfo() { return this.grammarInfo; }
    
    /**
     * Returns true if we should be collecting characters in the current element.
     */
    private final boolean shouldCollectText() {
        return this.collectText[this.stackTop];
    }
    
    public void startDocument() throws SAXException {
        // reset the object
        this.result = null;
        this.handlerLen=0;
        this.patchers=null;
        this.patchersLen=0;
        this.aborted = false;
        this.isUnmarshalInProgress = true;
        
        this.stackTop=0;
        this.elementDepth=1;
    }
    
    public void endDocument() throws SAXException {
        this.runPatchers();
        this.isUnmarshalInProgress = false;
    }
    
    public void startElement( String uri, String local, String qname, Attributes atts )
            throws SAXException {
        
        // work gracefully with misconfigured parsers that don't support namespaces
        if( uri==null ) {
			uri="";
		}
        if( (local==null) || (local.length()==0) ) {
			local=qname;
		}
        if( (qname==null) || (qname.length()==0) ) {
			qname=local;
		}
        
        if(this.result==null) {
            // this is the root element.
            // create a root object and start unmarshalling
            UnmarshallingEventHandler unmarshaller =
                this.grammarInfo.createUnmarshaller(uri,local,this);
            if(unmarshaller==null) {
                // the registry doesn't know about this element.
                //
                // the no.1 cause of this problem is that your application is configuring
                // an XML parser by your self and you forgot to call
                // the SAXParserFactory.setNamespaceAware(true). When this happens, you see
                // the namespace URI is reported as empty whereas you expect something else.
                throw new SAXParseException(
                    Messages.format( Messages.UNEXPECTED_ROOT_ELEMENT2,
                        uri, local, this.computeExpectedRootElements() ),
                    this.getLocator() );
            }
            this.result = unmarshaller.owner();

            this.pushContentHandler(unmarshaller,0);
        }
    
        this.processText(true);
    
        this.getCurrentHandler().enterElement(uri,local,qname,atts);
    }

    public final void endElement( String uri, String local, String qname )
            throws SAXException {
        
        // work gracefully with misconfigured parsers that don't support namespaces
        if( uri==null ) {
			uri="";
		}
        if( (local==null) || (local.length()==0) ) {
			local=qname;
		}
        if( (qname==null) || (qname.length()==0) ) {
			qname=local;
		}
        
        this.processText(false);
        this.getCurrentHandler().leaveElement(uri,local,qname);
    }
    
    
    
    
    
    /** Root object that is being unmarshalled. */
    private Object result;
    public Object getResult() throws UnmarshalException {
        if(this.isUnmarshalInProgress) {
			throw new IllegalStateException();
		}
        
        if(!this.aborted) {
			return this.result;
		}
        
        // there was an error.
        throw new UnmarshalException((String)null);
    }

    
    
//
//
// handler stack maintainance
//
//
    private UnmarshallingEventHandler[] handlers = new UnmarshallingEventHandler[16];
    private int[] mementos = new int[16];
    private int handlerLen=0;
    
    public void pushContentHandler( UnmarshallingEventHandler handler, int memento ) {
        if(this.handlerLen==this.handlers.length) {
            // expand buffer
            UnmarshallingEventHandler[] h = new UnmarshallingEventHandler[this.handlerLen*2];
            int[] m = new int[this.handlerLen*2];
            System.arraycopy(this.handlers,0,h,0,this.handlerLen);
            System.arraycopy(this.mementos,0,m,0,this.handlerLen);
            this.handlers = h;
            this.mementos = m;
        }
        this.handlers[this.handlerLen] = handler;
        this.mementos[this.handlerLen] = memento;
        this.handlerLen++;
    }
    
    public void popContentHandler() throws SAXException {
        this.handlerLen--;
        this.handlers[this.handlerLen]=null;  // this handler is removed
        this.getCurrentHandler().leaveChild(this.mementos[this.handlerLen]);
    }

    public UnmarshallingEventHandler getCurrentHandler() {
        return this.handlers[this.handlerLen-1];
    }


//
//
// text handling
//
//    
    private StringBuffer buffer = new StringBuffer();
    
    protected void consumeText( String str, boolean ignorable ) throws SAXException {
         if(ignorable && (str.trim().length()==0)) {
			// if we are allowed to ignore text and
            // the text is ignorable, ignore.
            return;
		}
        
        // otherwise perform a transition by this token.
        this.getCurrentHandler().text(str);
    }
    private void processText( boolean ignorable ) throws SAXException {
        if( this.shouldCollectText() ) {
			this.consumeText(this.buffer.toString(),ignorable);
		}
        
        // avoid excessive object allocation, but also avoid
        // keeping a huge array inside StringBuffer.
        if(this.buffer.length()<1024) {
			this.buffer.setLength(0);
		} else {
			this.buffer = new StringBuffer();
		}
    }
    
    public final void characters( char[] buf, int start, int len ) {
        if( this.shouldCollectText() ) {
			this.buffer.append(buf,start,len);
		}
    }

    public final void ignorableWhitespace( char[] buf, int start, int len ) {
        this.characters(buf,start,len);
    }



    
//
//
// namespace binding maintainance
//
//
    private String[] nsBind = new String[16];
    private int nsLen=0;
    
    // in the current scope, nsBind[0] - nsBind[idxStack[idxStackTop]-1]
    // are active.
    // use {@link #elementDepth} and {@link stackTop} to access.
    private int[] idxStack = new int[16];
    
    public void startPrefixMapping( String prefix, String uri ) {
        if(this.nsBind.length==this.nsLen) {
            // expand the buffer
            String[] n = new String[this.nsLen*2];
            System.arraycopy(this.nsBind,0,n,0,this.nsLen);
            this.nsBind=n;
        }
        this.nsBind[this.nsLen++] = prefix;
        this.nsBind[this.nsLen++] = uri;
    }
    public void endPrefixMapping( String prefix ) {
        this.nsLen-=2;
    }
    public String resolveNamespacePrefix( String prefix ) {
        if(prefix.equals("xml")) {
			return "http://www.w3.org/XML/1998/namespace";
		}
        
        for( int i=this.idxStack[this.stackTop]-2; i>=0; i-=2 ) {
            if(prefix.equals(this.nsBind[i])) {
				return this.nsBind[i+1];
			}
        }
        return null;
    }
    public String[] getNewlyDeclaredPrefixes() {
        return this.getPrefixList( this.idxStack[this.stackTop-1] );
    }

    public String[] getAllDeclaredPrefixes() {
        return this.getPrefixList( 2 );  // skip the default ""->"" mapping
    }
    
    private String[] getPrefixList( int startIndex ) {
        int size = (this.idxStack[this.stackTop]-startIndex)/2;
        String[] r = new String[size];
        for( int i=0; i<r.length; i++ ) {
			r[i] = this.nsBind[startIndex+i*2];
		}
        return r;
    }

    
    //
    //  NamespaceContext2 implementation 
    //
    public Iterator getPrefixes(String uri) {
        // wrap it into unmodifiable list so that the remove method
        // will throw UnsupportedOperationException.
        return Collections.unmodifiableList(
            this.getAllPrefixesInList(uri)).iterator();
    }
    
    private List getAllPrefixesInList(String uri) {
        List a = new ArrayList();
        
        if( uri.equals(XMLConstants.XML_NS_URI) ) {
            a.add(XMLConstants.XML_NS_PREFIX);
            return a;
        }
        if( uri.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI) ) {
            a.add(XMLConstants.XMLNS_ATTRIBUTE);
            return a;
        }
        if( uri==null ) {
			throw new IllegalArgumentException();
		}
          
        for( int i=this.nsLen-2; i>=0; i-=2 ) {
			if(uri.equals(this.nsBind[i+1])) {
				if( this.getNamespaceURI(this.nsBind[i]).equals(this.nsBind[i+1]) ) {
					// make sure that this prefix is still effective.
                    a.add(this.nsBind[i]);
				}
			}
		}
         
        return a;
    }

    public String getPrefix(String uri) {
        if( uri.equals(XMLConstants.XML_NS_URI) ) {
			return XMLConstants.XML_NS_PREFIX;
		}
        if( uri.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI) ) {
			return XMLConstants.XMLNS_ATTRIBUTE;
		}
        if( uri==null ) {
			throw new IllegalArgumentException();
		}
          
        for( int i=this.idxStack[this.stackTop]-2; i>=0; i-=2 ) {
			if(uri.equals(this.nsBind[i+1])) {
				if( this.getNamespaceURI(this.nsBind[i]).equals(this.nsBind[i+1]) ) {
					// make sure that this prefix is still effective.
                    return this.nsBind[i];
				}
			}
		}
         
        return null;
    }

     public String getNamespaceURI(String prefix) {
         if( prefix==null ) {
			throw new IllegalArgumentException();
		}
         if( prefix.equals(XMLConstants.XMLNS_ATTRIBUTE) ) {
			return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;
		}
        
         return this.resolveNamespacePrefix(prefix);
     }

//
//
// Attribute handling
//
//
    /**
     * Attributes stack.
     */
    private AttributesImpl[] attStack = new AttributesImpl[16];
    /**
     * Element nesting level.
     */
    private int elementDepth;
    /**
     * Always {@link #elementDepth}-1.
     */
    private int stackTop;
    
    /**
     * Stack of collectText flag.
     * False means text can be ignored for this element.
     * 
     * Use {@link #elementDepth} and {@link #stackTop} to access the array.
     */ 
    private boolean[] collectText = new boolean[16];
    
    public void pushAttributes( Attributes atts, boolean collectTextFlag ) {
        
        if( this.attStack.length==this.elementDepth ) {
            // reallocate the buffer
            AttributesImpl[] buf1 = new AttributesImpl[this.attStack.length*2];
            System.arraycopy(this.attStack,0,buf1,0,this.attStack.length);
            this.attStack = buf1;
            
            int[] buf2 = new int[this.idxStack.length*2];
            System.arraycopy(this.idxStack,0,buf2,0,this.idxStack.length);
            this.idxStack = buf2;
            
            boolean[] buf3 = new boolean[this.collectText.length*2];
            System.arraycopy(this.collectText,0,buf3,0,this.collectText.length);
            this.collectText = buf3;
        }
        
        this.elementDepth++;
        this.stackTop++;
        
        // push the stack
        AttributesImpl a = this.attStack[this.stackTop];
        if( a==null ) {
			this.attStack[this.stackTop] = a = new AttributesImpl();
		} else {
			a.clear();
		}
        
        // since Attributes object is mutable, it is criticall important
        // to make a copy.
        // also symbolize attribute names
        for( int i=0; i<atts.getLength(); i++ ) {
            String auri = atts.getURI(i);
            String alocal = atts.getLocalName(i);
            String avalue = atts.getValue(i);
            String aqname = atts.getQName(i);
            
            // work gracefully with misconfigured parsers that don't support namespaces
            if( auri==null ) {
				auri="";
			}
            if( (alocal==null) || (alocal.length()==0) ) {
				alocal=aqname;
			}
            if( (aqname==null) || (aqname.length()==0) ) {
				aqname=alocal;
			}

            // <foo xsi:nil="false">some value</foo> is a valid fragment, however
            // we need a look ahead to correctly handle this case.
            // (because when we process @xsi:nil, we don't know what the value is,
            // and by the time we read "false", we can't cancel this attribute anymore.)
            //
            // as a quick workaround, we remove @xsi:nil if the value is false.
            if( (auri=="http://www.w3.org/2001/XMLSchema-instance") && (alocal=="nil") ) {
                String v = avalue.trim();
                if(v.equals("false") || v.equals("0")) {
					continue;   // skip this attribute
				}
            }
            
            // otherwise just add it.
            a.addAttribute(
                    auri,
                    alocal,
                    aqname,
                    atts.getType(i),
                    avalue );
        }
        
        
        // start a new namespace scope
        this.idxStack[this.stackTop] = this.nsLen;
        
        this.collectText[this.stackTop] = collectTextFlag;
    }
    public void popAttributes() {
        this.stackTop--;
        this.elementDepth--;
    }
    public Attributes getUnconsumedAttributes() {
        return this.attStack[this.stackTop];
    }
    /**
     * @param uri,local
     *      has to be interned.
     */
    public int getAttribute( String uri, String local ) {
        return this.attStack[this.stackTop].getIndexFast(uri,local);
    }
    public void consumeAttribute( int idx ) throws SAXException {
        AttributesImpl a = this.attStack[this.stackTop];
        
        String uri = a.getURI(idx);
        String local = a.getLocalName(idx);
        String qname = a.getQName(idx);
        String value = a.getValue(idx);

        // mark the attribute as consumed
        // we need to remove the attribute before we process it
        // because the event handler might access attributes.
        a.removeAttribute(idx);
        
        
        this.getCurrentHandler().enterAttribute(uri,local,qname);
        this.consumeText(value,false);
        this.getCurrentHandler().leaveAttribute(uri,local,qname);
    }
    public String eatAttribute( int idx ) throws SAXException {
        AttributesImpl a = this.attStack[this.stackTop];
        
        String value = a.getValue(idx);

        // mark the attribute as consumed
        a.removeAttribute(idx);
        
        return value;
    }

//
//
// ID/IDREF related code
//
//
    /**
     * Submitted patchers in the order they've submitted.
     * Many XML vocabulary doesn't use ID/IDREF at all, so we
     * initialize it with null.
     */
    private Runnable[] patchers = null;
    private int patchersLen = 0;
    
    public void addPatcher( Runnable job ) {
        // re-allocate buffer if necessary
        if( this.patchers==null ) {
			this.patchers = new Runnable[32];
		}
        if( this.patchers.length == this.patchersLen ) {
            Runnable[] buf = new Runnable[this.patchersLen*2];
            System.arraycopy(this.patchers,0,buf,0,this.patchersLen);
            this.patchers = buf;
        }
        this.patchers[this.patchersLen++] = job;
    }
    
    /** Executes all the patchers. */
    private void runPatchers() {
        if( this.patchers!=null ) {
            for( int i=0; i<this.patchersLen; i++ ) {
				this.patchers[i].run();
			}
        }
    }

    /** Records ID->Object map. */
    private Hashtable idmap = null;

    public String addToIdTable( String id ) {
        if(this.idmap==null) {
			this.idmap = new Hashtable();
		}
        this.idmap.put( id, this.getCurrentHandler().owner() );
        return id;
    }
    
    public Object getObjectFromId( String id ) {
        if(this.idmap==null) {
			return null;
		}
        return this.idmap.get(id);
    }
    


//
//
// Other SAX callbacks
//
//
    public void skippedEntity( String name ) {
    }
    public void processingInstruction( String target, String data ) {
        // just ignore
    }
    public void setDocumentLocator( Locator loc ) {
        this.locator = loc;
    }
    public Locator getLocator() { return this.locator; }
    
    private Locator locator = DUMMY_LOCATOR;

    private static final Locator DUMMY_LOCATOR = new LocatorImpl();


//
//
// error handling
//
//
    private final UnmarshallerImpl parent;
    private boolean aborted = false;
    
    public void handleEvent(ValidationEvent event, boolean canRecover ) throws SAXException {
        ValidationEventHandler eventHandler;
        try {
            eventHandler = this.parent.getEventHandler();
        } catch( JAXBException e ) {
            // impossible.
            throw new JAXBAssertionError();
        }

        boolean recover = eventHandler.handleEvent(event);
        
        // if the handler says "abort", we will not return the object
        // from the unmarshaller.getResult()
        if(!recover) {
			this.aborted = true;
		}
        
        if( !canRecover || !recover ) {
			throw new SAXException( new UnmarshalException(
                event.getMessage(),
                event.getLinkedException() ) );
		}
    }
  
//
//
// ValidationContext implementation
//
//
    public String getBaseUri() { return null; }
    public boolean isUnparsedEntity(String s) { return true; }
    public boolean isNotation(String s) { return true; }


//
//
// debug trace methods
//
//
    private Tracer tracer;
    public void setTracer( Tracer t ) {
        this.tracer = t;
    }
    public Tracer getTracer() {
        if(this.tracer==null) {
			this.tracer = new Tracer.Standard();
		}
        return this.tracer;
    }
    
    /**
     * Computes the names of possible root elements for a better error diagnosis.
     */
    private String computeExpectedRootElements() {
        String r = "";
        
        String[] probePoints = this.grammarInfo.getProbePoints();
        for( int i=0; i<probePoints.length; i+=2 ) {
            if( this.grammarInfo.recognize(probePoints[i],probePoints[i+1]) ) {
                if(r.length()!=0) {
					r+=',';
				}
                r += "<{"+probePoints[i]+"}"+probePoints[i+1]+">";
            }
        }
        
        return r;
    }
}
