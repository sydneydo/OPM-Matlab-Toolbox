package extensionTools.sqlGeneration.xmlParsing;

import extensionTools.sqlGeneration.db.Column;
import extensionTools.sqlGeneration.db.Database;
import extensionTools.sqlGeneration.db.Table;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import extensionTools.sqlGeneration.util.Constants;
import extensionTools.sqlGeneration.xmlParsing.ObjectXMLCollection;

/**
 *                                 Class XMLParser - 
 *                                 
 *                                 
 * This is the main class from the program. 
 * It is responsible for parsing the XML file generated by Opcat II and
 * transforms it into a SQL script modeled to tables.
 */

public class XMLParser implements Constants
{
    Database db;
    TSSObjectCollection arrTssObjects = new TSSObjectCollection();
    ArrayList arrAgents = new ArrayList();
    
    public XMLParser()
    {
        db = new Database("OPCAT DataBase");
    }
    
    /**
     * Return DB
     * @return 
     */
    public Database getDatabase ()
    {
        return (db);
    }
    
    /**
     * Parses the given XML and generates Script.
     * @param fileToParse - XML File to parse.
     */
    public void parse (File fileToParse)
    {
        if (fileToParse.exists() == false)
        {
            logger.out("Error: XML File: " + fileToParse.getAbsolutePath() +
                        " does not exist");
        }
        
        /*
        ScriptRunner scriptRunner = new ScriptRunner(); 
        // Delete all tabvles
        File sc = new File(WORKING_DIR + "dropTables.txt");
        scriptRunner.runScriptResumeNext(sc);
        */
        
        SAXBuilder builder = new SAXBuilder();
         
        try {
          Document doc = builder.build(fileToParse);
          Element root1 = doc.getRootElement();
          
          ElementOpcat root = new ElementOpcat(root1);
          
          List children = root.getChildren();
          Iterator iterator = children.iterator();
           while (iterator.hasNext()) 
           {
              listChildren((ElementOpcat)iterator.next(), 0, null, null);       
           }           
           
           
           handleRelations(root);
           
           deleteProcesses();
           
           /*
           File fScript = new File("C:\\outDB01.txt");
           ScriptCreator scr = new ScriptCreator();
           scr.createScript(fScript, db);
           
           ScriptRunner runner = new ScriptRunner();
           runner.runScript(fScript);
           */
        }
        // indicates a well-formedness error
        catch (JDOMException e) { 
          System.out.println(fileToParse + " is not well-formed.");
          System.out.println(e.getMessage());
        }  
        catch (IOException e) { 
          System.out.println(e);
        }  
    }
    
     /**
     * 
     * @param current - current TSS
     * @param depth - 
     * @param realFatherName - name of the recursive father entity
     * @param cardinality - cardinality of this TSS, cardinality to father
     *                      is always 1 
     *                      Value can be: 1 --> one cardinalty
     *                                    other ---> many cardinalty
     */
    public void listChildren(ElementOpcat child, int depth, String realFatherName,
                            String cardinality) 
    {
        
        //System.out.println(current.getName());
       
        String tssName;
        String transID;
        if(child.getName().equalsIgnoreCase(TSS))
      {   
          tssName = child.getAttributeValue(TSS_NAME , null); 
          transID = child.getAttributeValue(TRANS_ID, null);
          
          //Saving the TSS attributes for later use.
          TSSObject tssObject = new TSSObject(cardinality , realFatherName, 
                                                tssName, transID, null);
          //Adding new TSSObject into the array collection.
          arrTssObjects.add(tssObject);
          
          //Complex Entity (has sons)
          if(transID.equalsIgnoreCase("0"))
          {
              //In complex entity always create table.   
              createTablePK(tssName);              
              
              if(realFatherName != null)
              {
                  if (cardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
                    {
                        // If this ONE cardinalty so we need:
                        // 2) Add FK to father table
                        addFKtoTable(realFatherName , tssName);
                    }
                    else
                    {
                        // If this MANY cardinalty so we need:
                        // 1) Create table for son
                        // 2) Add FK to this table (son)
                        addFKtoTable(tssName, realFatherName);
                    }
              }
              
              handleComplexTSSSets(child , tssName, depth);              
          }
          // Simple Entity (has no sons)
          else if(transID.equalsIgnoreCase("0") == false && 
                    transID.equalsIgnoreCase("2") == false)
          {
               if (child.getAttribute(AGG_FATHER) == null)
               {
                   if (child.getAttribute(EXB_FATHER) == null)
                   {
                        // There is no father at all
                        createTablePK(tssName);                                                 
                   }
                   else
                   {
                       // HAS EXB_FATHER then:
                       // if Cardinality != 1 create table and FK son.
                       // else add attribute to father.
                       if (db.isTableExists(tssName) == false)
                       {
                           if(cardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
                           {
                                //fatherName = child.getAttribute(EXB_FATHER).getValue();
                               // Table father = db.getTableByName(fatherName);
                                Table father = db.getTableByName(realFatherName);
                                Column colRegular = Column.createColumn(tssName, "\"NIY DATA TYPE\"", 
                                                false, true, true, false, null, null, 0 );
                                
                                father.addColumn(colRegular); 
                           }
                           else
                           {
                                createTablePK(tssName);
                                addFKtoTable(tssName , realFatherName);                            
                           }
                       }
                       //if son table already exist
                       // add FK.
                       else
                       {
                           if(cardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
                           {
                                addFKtoTable(realFatherName , tssName);
                           }
                           else
                           {
                                addFKtoTable(tssName, realFatherName);                            
                           }
                       }
                   }
               }
               // Has AGG Father.
               else
               {
                    if (cardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
                    {
                        // If this ONE cardinalty so we need:
                        // 1) Create table for son
                        // 2) Add FK to father table
                        createTablePK(tssName);
                        
                        addFKtoTable(realFatherName , tssName);                        
                    }
                    else
                    {
                        // If this MANY cardinalty so we need:
                        // 1) Create table for son
                        // 2) Add FK to this table (son)
                        createTablePK(tssName);
                        
                        String fatherPK = null;
                        fatherPK = db.getTablePKByName(realFatherName); 
                        
                        addFKtoTable(tssName , fatherPK, realFatherName);
                    }
               }
          }
      }
    }
    
    /**
     * This function represents a "2nd phase" of the algorithm.
     * It searches for all relations (UNI-... and BI-...) and handles it.
     * 
     * @param currElement - any element of the XML file
     */
    private void handleRelations (ElementOpcat currElement)
    {
        // TSS can contain RELATION sentence
        if (currElement.getName().equalsIgnoreCase(TSS) &&
            currElement.getAttributeValue(TRANS_ID, "NOTRANS").
                                            equalsIgnoreCase("2") == false)
        {
            ElementOpcat currRelation = null;
            Iterator it = null;
            
            // HANDLE UNI - DIR - RELATIONS
            List uniRelations = currElement.getChildren(UNIDIR_SENTENCE);
            it = uniRelations.iterator();
            while (it.hasNext())
            {
                currRelation = (ElementOpcat)it.next();
                handleSingleRelation(currRelation);
            }
            
            // HANDLE BI - DIR - RELATIONS
            List biRelations = currElement.getChildren(BIDIR_SENTENCE);
            it = biRelations.iterator();
            while (it.hasNext())
            {
                currRelation = (ElementOpcat)it.next();
                handleSingleRelation(currRelation);
            }   
        }
        
        // Recursive call for all children
        List children = currElement.getChildren();
        {
            ElementOpcat currChild = null;
            Iterator itRecur = children.iterator();
            while (itRecur.hasNext())
            {
                currChild = (ElementOpcat)itRecur.next();
                handleRelations(currChild);
            }
        }
    }
    
    /**
     * This function handles single relation (UNI directional or
     * BI - directional)
     * @param eleRelation
     */
    private void handleSingleRelation (ElementOpcat eleRelation)
    {
        String srcCarinality = eleRelation.getChildText(SRC_MAX_CARDINALITY);
        String srcName = eleRelation.getChildText(SRC_NAME);
        String destCardinality = eleRelation.getChildText(DEST_MAX_CARDINALITY);
        String destName = eleRelation.getChildText(DEST_NAME);

        
        // SRC 1 - 1 DEST
        if (srcCarinality.equalsIgnoreCase(CARDINALITY_ONE) == true &&
            destCardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
        {
            handleRelationOneToOne(srcName, destName);
        }
        // SRC N - 1 DEST
        else if (srcCarinality.equalsIgnoreCase(CARDINALITY_ONE) == false &&
            destCardinality.equalsIgnoreCase(CARDINALITY_ONE) == true)
        {
            handleRaletionOneToMany(destName, srcName);
        }
        // SRC 1 - N DEST
        else if (srcCarinality.equalsIgnoreCase(CARDINALITY_ONE) == true &&
            destCardinality.equalsIgnoreCase(CARDINALITY_ONE) == false)
        {
            handleRaletionOneToMany(srcName, destName);
        }
        // SRC N - N DEST 
        else if (srcCarinality.equalsIgnoreCase(CARDINALITY_ONE) == false &&
            destCardinality.equalsIgnoreCase(CARDINALITY_ONE) == false)
        {
            handleRelationManyToMany(srcName, destName);
        }
    }
    
    /**
     * Handle one to one relation
     * @param srcTable
     * @param destTable
     */
    private void handleRelationOneToOne (String srcTableName, String destTableName)
    {
        Table srcTable = db.getTableByName(srcTableName);
        Table destTable = db.getTableByName(destTableName); 
        Table srcFatherTable = null;
        Table destFatherTable = null;
        Column colFK = null;
        String srcFatherName;
        String destFatherName;
        TSSObject tssObject;
        
        // Both tables exist
        if (srcTable != null && destTable != null)
        {
            addFKtoTable(srcTableName, destTableName);
        }
        // Only srcTable exist
        else if (srcTable != null && destTable == null)
        {
            tssObject = arrTssObjects.getTSSObjectByAttributeName(destTableName);
            if (tssObject == null) return;
            destFatherName = tssObject.getRealFatherName();
            destFatherTable = db.getTableByName(destFatherName);
            colFK = destFatherTable.getColumnByName(destTableName); // Its a column
            colFK.addFK(srcTableName, db);
        }
        // Only destTable exist
        else if (srcTable == null && destTable != null)
        {
            tssObject = arrTssObjects.getTSSObjectByAttributeName(srcTableName);
            if (tssObject == null) return;
            srcFatherName = tssObject.getRealFatherName();
            srcFatherTable = db.getTableByName(srcFatherName);
            colFK = srcFatherTable.getColumnByName(srcTableName); // Its a column
            colFK.addFK(destTableName, db);
        }
        // Both tables doest not exist
        else
        {
            // Add FK to dest's father references src's father
            tssObject = arrTssObjects.getTSSObjectByAttributeName(destTableName);
            if (tssObject == null) return;
            destFatherName = tssObject.getRealFatherName();
            destFatherTable = db.getTableByName(destFatherName);
            colFK = destFatherTable.getColumnByName(destTableName); // Its a column
            
            tssObject = arrTssObjects.getTSSObjectByAttributeName(srcTableName);
            srcFatherName = tssObject.getRealFatherName();
            
            colFK.addFK(srcTableName, db);
        }
    }
    
    /**
     * Handle one to many relation
     * @param srcTable
     * @param destTable
     */
    private void handleRaletionOneToMany (String srcTableName, String destTableName)
    {
        Table srcTable = db.getTableByName(srcTableName);
        Table destTable = db.getTableByName(destTableName); 
        Table destFatherTable = null;
        Column colFK = null;
        String srcFatherName;
        String destFatherName;
        TSSObject tssObject;
        
        // Both tables exist
        if (srcTable != null && destTable != null)
        {
            addFKtoTable(destTableName, srcTableName);
        }
        // Only srcTable exist
        else if (srcTable != null && destTable == null)
        {
            // add FK to dest column (in dest's father) references src table
            tssObject = arrTssObjects.getTSSObjectByAttributeName(destTableName);
            if (tssObject == null) return;
            destFatherName = tssObject.getRealFatherName();
            destFatherTable = db.getTableByName(destFatherName);
            colFK = destFatherTable.getColumnByName(destTableName); // Its a column
            colFK.addFK(srcTableName, db);
        }
        // Only destTable exist
        else if (srcTable == null && destTable != null)
        {
            // Add new FK column to dest table references src column (in src's father)
            tssObject = arrTssObjects.getTSSObjectByAttributeName(srcTableName);
            if (tssObject == null) return;
            srcFatherName = tssObject.getRealFatherName();
            
            addFKtoTable(destTableName, srcTableName, srcFatherName);
        }
        // Both tables doest not exist
        else
        {
            // 1) Take dest column from dest's father and make from it dest table
            // 2) Add FK to dest column in dest's father
            // 3) Add FK column (named src) to dest table references src's father
            
            // 1)
            createTablePK(destTableName);
            
            // 2)
            tssObject = arrTssObjects.getTSSObjectByAttributeName(destTableName);
            if (tssObject == null) return;
            destFatherName = tssObject.getRealFatherName();
            destFatherTable = db.getTableByName(destFatherName);
            colFK = destFatherTable.getColumnByName(destTableName); // Its a column
            colFK.addFK(destTableName, db);
            
            // 3)
            tssObject = arrTssObjects.getTSSObjectByAttributeName(srcTableName);
            srcFatherName = tssObject.getRealFatherName();
            addFKtoTable(destTableName, srcTableName, srcFatherName);
        }
    }
    
    /**
     * Handle many to many realtion
     * @param srcTable
     * @param destTable
     */
    private void handleRelationManyToMany (String srcTableName, String destTableName)
    {
        Table srcTable = db.getTableByName(srcTableName);
        Table destTable = db.getTableByName(destTableName); 
        String relTableName = srcTableName + "_" + destTableName + "_REL";
        
        // In many to many relation we need relation table with 2 PKs.
        Table tblSrcDestRelation = new Table(relTableName);
        Column colPK_1 = Column.createColumn(srcTableName , Column.DATA_TYPE_INTEGER,
                                10, true);
        tblSrcDestRelation.addColumn(colPK_1);
        Column colPK_2 = Column.createColumn(destTableName , Column.DATA_TYPE_INTEGER,
                                10, true);
        tblSrcDestRelation.addColumn(colPK_2);
        db.addTable(tblSrcDestRelation);

        if (srcTable == null)
        {
            if (turnColumnToTable(srcTableName) == false)
            {
                return;
            }
        }
        
        if (destTable == null)
        {
            if (turnColumnToTable(destTableName) == false)
            {
                return;
            }
        }
        
        // Add FKeys to relation table
        colPK_1.addFK(srcTableName, db);
        colPK_2.addFK(destTableName, db);
    }
    
    /**
     * 1) Take X column from X's father and make from it X table
     * 2) Add FK to X column in X's father
     * @param columnThatHasTSS
     */
    private boolean turnColumnToTable (String columnThatHasTSS)
    {
        String fatherName;
        Table fatherTable;
        Column colFK;
        TSSObject tssObject;
        // 1)
        createTablePK(columnThatHasTSS);
        
        // 2)
        tssObject = arrTssObjects.getTSSObjectByAttributeName(columnThatHasTSS);
        if (tssObject == null) return (false);
        fatherName = tssObject.getRealFatherName();
        fatherTable = db.getTableByName(fatherName);
        colFK = fatherTable.getColumnByName(columnThatHasTSS); // Its a column
        colFK.addFK(columnThatHasTSS, db);   
        return (true);
    }
    
    
    /**
     * Returns all the XXXObjects inside a sentence.
     * @param element - The sentence element.
     * @return List of objects.
     */
    private ObjectXMLCollection getXMLObjectsFromOES(ElementOpcat element) 
    {
        ObjectXMLCollection colObjects = new ObjectXMLCollection();
        List list = element.getChildren();
        Iterator it = list.iterator();
        
        String elementName;
        ElementOpcat currElement;
        
        while(it.hasNext())
        {
            currElement = (ElementOpcat)it.next();
            elementName = currElement.getName();
            if(elementName.equalsIgnoreCase(AGG_OBJECT) ||
               elementName.equalsIgnoreCase(EXB_OBJECT) ||
               elementName.equalsIgnoreCase(STATE_OBJECT))
            {
                colObjects.add(getXMLObject(currElement));
            }
            else if (elementName.equalsIgnoreCase(INH_ATTRIBUTE_NAME))
            {   
                ObjectXML objectXML = new ObjectXML();
                objectXML.setAttrName(currElement.getValue());
                colObjects.add(objectXML);
            }
            
        }
        
        return (colObjects);
    }
    
    /**
     * Returns a XMLObject from an Object Element.
     * @param element - Object Element.
     * @return ObjectXML.
     */
    private ObjectXML getXMLObject(ElementOpcat element)
    {
        List list = element.getChildren();
        Iterator it = list.iterator();
        
        String elementName;
        ElementOpcat currElement;
        ObjectXML objectXMl = new ObjectXML();
        
        while(it.hasNext())
        {
            currElement = (ElementOpcat)it.next();
            elementName = currElement.getName();            
            
            if(elementName.equalsIgnoreCase(AGG_ATTRIBUTE_NAME) || 
                elementName.equalsIgnoreCase(EXB_ATTRIBUTE_NAME) ||
                elementName.equalsIgnoreCase(STATE_ATT_NAME))
            {
               objectXMl.setAttrName(currElement.getValue());
            }
            if(elementName.equalsIgnoreCase(MAX_CARDINALITY))
            {
               objectXMl.setMaxCardinality(currElement.getValue());
            }
        }
        return objectXMl;
    }
    
    /**
     * Adds a column with a forgien key to a the table.
     * @param tableName - Table to add the column.
     * @param referenceTableName - the reference table.
     */
    private void addFKtoTable(String tableName, String referenceTableName)
    {
        Table tbl = db.getTableByName(tableName);
                        Column colFK = Column.createColumn(referenceTableName  , Column.DATA_TYPE_INTEGER, 
                        false, true, true, true, referenceTableName, db, 10);
                        tbl.addColumn(colFK);
    }
    
    /**
     * Adds a column with a forgien key to a the table. the column name is Explicit.
     * @param columnName - the new column's name.
     * @param tableName - Table to add the column.
     * @param referenceTableName - the reference table.
     */
    private void addFKtoTable(String tableName,String columnName ,String referenceTableName)
    {
        Table tbl = db.getTableByName(tableName);
                        Column colFK = Column.createColumn(columnName, Column.DATA_TYPE_INTEGER, 
                        false, true, true, true, referenceTableName, db, 10);
                        tbl.addColumn(colFK);
    }
    
    /**
     * create a new table with a primary key with the name as the table.
     * @param tableName - the new table's name.
     */
    private void createTablePK(String tableName)
    {
        Table tblComplexEntity = new Table(tableName);
        Column colPK = Column.createColumn(tableName  ,Column.DATA_TYPE_INTEGER, 10, true);                  
        tblComplexEntity.addColumn(colPK);
        db.addTable(tblComplexEntity);
    }
    
    /**
     * This function creates inherited table 
     * The assumption is that father table exists
     * Son table is created and all columns of father copied to son table
     * 
     * @param fatherTableName
     * @param sonTableName
     */
    private void createInheritedSonTable (String fatherTableName, String sonTableName)
    {
        Table tblFather = db.getTableByName(fatherTableName);
        
        if (tblFather == null)
        {
            logger.out("Error: Trying to inherit from table " + fatherTableName + 
                        " but the table does not exist");
        }
        
        Table tblInheritedSon = db.getTableByName(sonTableName);
        
        if (tblInheritedSon == null)
        {
            tblInheritedSon = new Table (sonTableName);
            db.addTable(tblInheritedSon);
        }
        //If table exist, then it was already created as complex Entity,
        //and son cannot have his own primary key.
        //then delete son primary key.
        else
        {
            tblInheritedSon.dropColumn(sonTableName);
        }
        
        //tblInheritedSon.get
        ArrayList arrColumns = tblFather.getColumns();
        Iterator it = arrColumns.iterator();
        Column currColumn = null;
        Column newColumn = null;
        
        String PKname = null;
        
        while (it.hasNext())
        {
            currColumn = (Column)it.next();
            if(currColumn.getIsPrimaryKey())
            {
                PKname = currColumn.getName();
            }
            newColumn = Column.createColumn(currColumn, db);
            tblInheritedSon.addColumn(newColumn);
        }
        
        if (PKname != null)
        {
            db.addInheritedReferences(sonTableName , PKname);
        }
    }
    /**
     * create a new table with a primary key with the name as the table.
     * @param tableName - the new table's name.
     */
    private void createTableExplicitPK(String tableName, String nameOfPK)
    {
        Table tblComplexEntity = new Table(tableName);
        Column colPK = Column.createColumn(nameOfPK ,Column.DATA_TYPE_INTEGER , 10, true);                  
        tblComplexEntity.addColumn(colPK);
        db.addTable(tblComplexEntity);
    }
    
    /**
     * Updates a column in a table to become a forgien key.
     * @param tableName - the table that the column is in.
     * @param columnName - the column.
     * @param referenceTable - the reference the for the FK.
     */
    private void addFKtoExistColumn(String tableName, String columnName, String referenceTable )
    {
        Table tbl = db.getTableByName(tableName);
        Column col = tbl.getColumnByName(columnName);
        col.addFK(referenceTable , db);
    }
    
    /**
     * Go through all the ObjectsXML with no TSS and create the proper table
     * model. this collection can hold both Agg / Exh objects, but only one
     * at a time.
     * @param OXC - the ObjectXML collection.
     * @param tssName - the current element name.
     */
    private void goThoughXMLObjects(ObjectXMLCollection OXC, String tssName)
    {
          Iterator itOXC = OXC.iterator();
          ObjectXML currXMLObject;
          
          while(itOXC.hasNext())
          {
              currXMLObject = (ObjectXML)itOXC.next();
              if(db.isTableExists(currXMLObject.getAttrName()))
              {
                    //If Cardinality is One To One, then creat FK 
                    //at father. else FK Son.
                  if(currXMLObject.getMaxCardinality().
                        equalsIgnoreCase(CARDINALITY_ONE) == false)
                  {
                      addFKtoTable(currXMLObject.getAttrName() , tssName);                                  
                  }
                    //this is the one to one case.
                  else
                  {
                      addFKtoTable(tssName , currXMLObject.getAttrName()); 
                  }
              }
              // Table does not exists. and connection is AGG.
              // So we sure that cardinality to 
              // create table and update other father.
              else
              {
                  createTablePK(currXMLObject.getAttrName());
                  
                  if(currXMLObject.getMaxCardinality().
                        equalsIgnoreCase(CARDINALITY_ONE) == false)
                  {
                      addFKtoTable(currXMLObject.getAttrName() , tssName);                                  
                  }
                    //this is the one to one case.
                  else
                  {
                      addFKtoTable(tssName , currXMLObject.getAttrName()); 
                  }
                  TSSObject tssObject = (TSSObject)arrTssObjects.getTSSObjectByAttributeName(currXMLObject.getAttrName());
                  if (tssObject != null)
                  {
                      addFKtoExistColumn(
                            tssObject.getRealFatherName() , currXMLObject.getAttrName(), 
                            currXMLObject.getAttrName());
                  }
                  
                    //If Cardinality is One To One, then creat FK 
                    //at father. else FK Son.                              
                  //addFKtoTable(realFatherName , currXMLObject.getAttrName());
              }
          }
    }
    
    /**
     * Handles Sentences Sets of type Agg and Exb due to similar handling.
     * @param sentenceSet - the Sentence XML element.
     * @param tssName - The TSS name.
     * @param depth - the current recursive depth.
     */
    private void handleSentenceSet(ElementOpcat sentenceSet,String tssName, int depth)
    {
       List listChildren = sentenceSet.getChildren();
       Iterator it1 = listChildren.iterator();
       ElementOpcat currChild;
       ObjectXMLCollection OXC = new ObjectXMLCollection();
       ObjectXML currXMLObject;
      
       while (it1.hasNext())
       {
          currChild =(ElementOpcat)it1.next();
          //
          if(currChild.getName().equalsIgnoreCase(AGG_SENTENCE) ||
            currChild.getName().equalsIgnoreCase(EXB_SENTENCE))
          {
              OXC = getXMLObjectsFromOES(currChild);
          }
          if(currChild.getName().equalsIgnoreCase(TSS))
          {
               currXMLObject = OXC.getXMLObjectByAttributeName(
                    currChild.getAttributeValue(TSS_NAME , null));
                    
               OXC.removeXMLObject(currXMLObject.getAttrName());          
                
               listChildren(currChild, depth, tssName, 
                                currXMLObject.getMaxCardinality());  
          }
      }
      goThoughXMLObjects(OXC , tssName); 
    }
    
    /**
     * Go through all the ObjectsXML with no TSS and create the proper table
     * model. this collection can hold only Inheritance objects. 
     * @param OXC - the ObjectXML collection.
     * @param tssName - the current element name.
     */
    private void goThoughXMLObjectsInheritance(ObjectXMLCollection OXC, String tssName)
    {
          Iterator itOXC = OXC.iterator();
          ObjectXML currXMLObject;
          
          while(itOXC.hasNext())
          {
              currXMLObject = (ObjectXML)itOXC.next();
              if(db.isTableExists(currXMLObject.getAttrName()))
              {
                 createInheritedSonTable(currXMLObject.getAttrName(), tssName);
              }
              else
              {
                  TSSObject tssObject = arrTssObjects.
                        getTSSObjectByAttributeName(currXMLObject.getAttrName());
                        
                  // In this case father does not exist at all (not as table,
                  // and not as attribute in other table)
                  // So we will not support this case of multiple inheritance
                  if(tssObject == null)
                  {
                      logger.out ("Java does not support multiple inheritance!!!");
                  }
                  //Father table is an attribute inside another table.
                  //then 1) create father table.
                  // 2) update grandfather table.
                  // 3) create son table.
                  else
                  {
                      String fatherName = tssObject.getName();
                      
                      // 1) Create father
                      createTablePK(fatherName);
                      
                      // 2) Get grandfather and update it
                      String grandFatherName = tssObject.getRealFatherName();
                      addFKtoExistColumn(grandFatherName, fatherName, fatherName);
                      
                      // 3) Create son table
                      createInheritedSonTable(fatherName, tssName);
                  }                     
              }
          }
    }
    
    /**
     * Go thourgh all complex Tss's and create thier modeles. 
     * @param elementTSS - the complex TSS element.
     * @param tssName - the tssName.
     * @param depth - the recursive depth.
     */
    private void handleComplexTSSSets(ElementOpcat elementTSS, String tssName, int depth)
    {
        // Check all children of the TSS
          List listOfTags = elementTSS.getChildren();
          Iterator it = listOfTags.iterator();
          String currElementName = null;
          ElementOpcat currElement = null;
          
          //go through the elements in the TSS and find the Agg / Exb
          //sets.
          while (it.hasNext())
          {
              currElement = (ElementOpcat)it.next();
              currElementName = currElement.getName();
              //if the Element child is Exhibition then enter here
              if (currElementName.equalsIgnoreCase(EXB_SET))
              {
                handleSentenceSet(currElement, tssName, depth);                    
              }
              //if the Element child is Aggrigation then enter here
              if(currElementName.equalsIgnoreCase(AGG_SET))
              {
                handleSentenceSet(currElement, tssName, depth);                    
              }
              //if true then connection is inheritance and we should create
              //a table for the son with PK of father and all his other
              //attributes.
              if(currElementName.equalsIgnoreCase(INHER_SET))
              {
                  List listChildren = currElement.getChildren();
                  Iterator it1 = listChildren.iterator();
                  ElementOpcat currChild;
                  ObjectXMLCollection OXC = new ObjectXMLCollection();                  
                  
                  while (it1.hasNext())
                  {
                      currChild =(ElementOpcat)it1.next();
                      //
                      if(currChild.getName().equalsIgnoreCase(INH_SENTENE))
                      {
                          OXC = getXMLObjectsFromOES(currChild);
                      }                          
                  }
                  goThoughXMLObjectsInheritance(OXC , tssName); 
              }
              //If this is true then Entity has States.
              if(currElementName.equalsIgnoreCase(STATE_SENTENCE))
              {
                  //Create the column to be added to the state holder.
                  Column colState = Column.createColumn(tssName + COLUMN_STATE_ID, Column.DATA_TYPE_INTEGER, 
                                                    false, true, true, false, null, null, 10);
                  
                  Table tbl = db.getTableByName(tssName);              
                  tbl.addColumn(colState);
                                    
                  //then create the States table with FK to father.
                  createTableExplicitPK(tssName + STATE_TABLE, tssName + COLUMN_STATE_ID);
                  addFKtoExistColumn(tssName , tssName + COLUMN_STATE_ID, tssName + STATE_TABLE);
                  
                  //then add the description column.
                  Column colStateDesc = Column.createColumn(tssName + COLUMN_STATE_DESC, Column.DATA_TYPE_VARCHAR, 
                                                    false, true, true, false, null, null, 10);
                  
                  Table tblState = db.getTableByName(tssName + STATE_TABLE);
                  tblState.addColumn(colStateDesc);
                  
                  ObjectXMLCollection OXC = new ObjectXMLCollection();                  
                  
                  //get all the states from the sentence.                  
                  OXC = getXMLObjectsFromOES(currElement);
                  
                  //Handle all the states.                  
                  goThoughXMLObjectsState(OXC , tssName);
              }
              if(currElementName.equalsIgnoreCase(AGENT_SENTENCE))
              {
                  //if here then we encountered an Agent and we need to get its
                  //information.
                  
                  List listChildren = currElement.getChildren();
                  Iterator it1 = listChildren.iterator();
                  ElementOpcat currChild;
              
                  
                  while (it1.hasNext())
                  {
                      currChild =(ElementOpcat)it1.next();
                      //
                      if(currChild.getName().equalsIgnoreCase(AGENT_ATTRIBUTE_NAME))
                      {
                          arrAgents.add(currChild.getValue());                          
                      }                          
                  }                  
              }
          }
    }
    
    /**
     * goes through the XMLobjects of type State and creates the state table
     * and columns.
     * @param OXC - the XMLobjects collection.
     * @param tssName - the father tss name.
     */
    private void goThoughXMLObjectsState(ObjectXMLCollection OXC, String tssName)
    {
      Iterator itOXC = OXC.iterator();
      ObjectXML currXMLObject;
      
      Table tblStates = db.getTableByName(tssName + STATE_TABLE);
      
      while(itOXC.hasNext())
      {
           currXMLObject = (ObjectXML)itOXC.next();
           tblStates.insertRow(currXMLObject.getAttrName());
      }
    }
    
    private void deleteProcesses()
    {
        Iterator it = arrAgents.iterator();
        String agentName = null;
        while(it.hasNext())
        {
            agentName = (String)it.next();
            if(db.isTableExists(agentName))
            {
                db.dropTable(agentName);
                logger.out("Message: Agent " + agentName + " was deleted.");
            }
        }
    }
    
    public static void main(String[] args)
    {
        XMLParser xmlParse = new XMLParser();
        xmlParse.parse(new File(WORKING_DIR + "test03.xml"));
    }
    
}